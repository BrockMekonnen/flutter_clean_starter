{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flutter Clean Starter","text":"<p>Welcome to the Flutter Clean Starter \u2013 a production-ready, modular, and scalable Flutter project template built using Clean Architecture principles.</p> <p>This starter project is designed to help Flutter developers kick-start new apps with:  </p> <ul> <li>Clean architecture layers (data, domain, features)  </li> <li>Modular code organization  </li> <li>Support for mobile and web  </li> <li>Localization, theme, and routing setup  </li> <li>Mock API server for quick prototyping  </li> </ul>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\u2705 Clean architecture: <code>domain</code>, <code>data</code>, and <code>features</code> layers</li> <li>\ud83d\udce6 Modular structure with feature-based folders</li> <li>\ud83e\uddea Testing-ready setup with <code>__tests__</code></li> <li>\ud83c\udf10 Localization with <code>easy_localization</code></li> <li>\ud83c\udfa8 Custom theming and layout</li> <li>\ud83c\udf0d Routing with <code>GoRouter</code></li> <li>\ud83d\udce1 Mock API (Dart server) included</li> <li>\ud83e\uddba Error handling, DI, and state management (Bloc)</li> <li>\ud83d\udca1 Supports Web, Android, and iOS</li> </ul>"},{"location":"#folder-structure-overview","title":"\ud83d\udcc1 Folder Structure Overview","text":"<p>Here's a simplified version of the core project structure:</p> <p><pre><code>lib/  \n\u251c\u2500\u2500 __tests__/  \n\u251c\u2500\u2500 _core/  \n\u251c\u2500\u2500 _shared/  \n\u251c\u2500\u2500 modules/  \nmock/  \ndocs/  \n</code></pre> Each module is self-contained with its own routes, features, domain, and data layers.</p>"},{"location":"#get-started","title":"\ud83d\ude80 Get Started","text":"<p>Head over to Getting Started to learn how to run, configure, and use this template effectively.</p>"},{"location":"#documentation-index","title":"\ud83d\udcd6 Documentation Index","text":"<ul> <li>Getting Started</li> <li>Architecture</li> <li>Folder Structure</li> <li>Core</li> <li>Modules</li> </ul>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Project Architecture","text":"<p>This project follows a robust Clean Architecture pattern, structured to ensure separation of concerns, modularity, and scalability. What sets this implementation apart is its modular design, where each feature lives in an isolated module with its own layers, routes, and logic.</p>"},{"location":"architecture/#clean-architecture-layers","title":"\ud83e\uddf1 Clean Architecture Layers","text":"<p>Each module and shared component follows the classic Clean Architecture principles:</p> <ul> <li>Domain Layer \u2014 Business logic, entities, and contracts (abstract repositories, use cases)</li> <li>Data Layer \u2014 Concrete implementations for repositories, local/remote data sources</li> <li>Feature Layer \u2014 UI, state management (BLoC), and presentation logic</li> </ul> <p>This separation enables each layer to be independently testable, replaceable, and loosely coupled.</p>"},{"location":"architecture/#modular-design","title":"\ud83d\udce6 Modular Design","text":"<p>The app is split into independent modules, each responsible for a specific domain (e.g., Auth, Posts, etc.).</p>"},{"location":"architecture/#why-modules","title":"\u2705 Why Modules?","text":"<ul> <li>\ud83e\udde9 Self-contained: Each module contains its own domain, data, and feature layers.</li> <li>\ud83d\udc65 Team-friendly: Multiple teams can work on different modules independently.</li> <li>\u2795 Pluggable: Modules can be easily added or removed without touching the core app.</li> <li>\ud83d\udcc1 Organized: Cleaner structure and simpler onboarding for new developers.</li> </ul>"},{"location":"architecture/#module-structure","title":"\ud83d\uddc2\ufe0f Module Structure","text":"<p>A typical module (e.g., auth) is structured like this: <pre><code>modules/\n\u2514\u2500\u2500 auth/\n    \u251c\u2500\u2500 data/       # Data sources, models, repositories\n    \u251c\u2500\u2500 domain/     # Entities, use cases, repository contracts\n    \u251c\u2500\u2500 features/   # BLoC, UI, screens\n    \u251c\u2500\u2500 auth_module.dart     # Module entry (DI and initializations)\n    \u2514\u2500\u2500 auth_routes.dart     # Module routes and nav registration\n</code></pre></p>"},{"location":"architecture/#module-registration","title":"\ud83d\udd0c Module Registration","text":"<p>Each module registers itself through:</p> <ul> <li>*_module.dart \u2192 Used to initialize dependencies (e.g., repositories, use cases)</li> <li>*_routes.dart \u2192 Used to register routes and navigation tabs in the global app router</li> </ul> <p>This enables complete decoupling of routing and logic between modules.</p>"},{"location":"architecture/#shared-components","title":"\ud83c\udf10 Shared Components","text":"<p>Common logic is placed in the _shared directory:</p> <ul> <li>blocs/ \u2014 Reusable BLoCs across modules</li> <li>widgets/ \u2014 Shared widgets</li> <li>utils/ \u2014 Utility functions</li> <li>data/ &amp; domain/ \u2014 Shared services and models</li> <li>features/ \u2014 Shared features not tied to a specific module</li> </ul>"},{"location":"architecture/#module-lifecycle","title":"\ud83d\udd01 Module Lifecycle","text":"<p>Each module follows a consistent lifecycle:</p> <ol> <li>\u2705 Define use cases, entities, and contracts in the domain/</li> <li>\ud83d\udd17 Implement data sources and repositories in the data/</li> <li>\ud83c\udfa8 Build BLoCs and UI in the features/</li> <li>\ud83d\udee0\ufe0f Initialize dependencies in *_module.dart</li> <li>\ud83e\udded Register routes in *_routes.dart</li> </ol>"},{"location":"architecture/#testability","title":"\ud83e\uddea Testability","text":"<p>The separation of layers and modules allows:</p> <ul> <li>Easy unit testing of business logic and use cases</li> <li>Mocking of repositories in isolation</li> <li>Clean widget and BLoC testing within each feature</li> </ul>"},{"location":"architecture/#visual-overview","title":"\ud83e\udded Visual Overview","text":"<pre><code>lib/\n\u251c\u2500\u2500 _core/           # Core setup (DI, routing, theming)\n\u251c\u2500\u2500 _shared/         # Reusable logic and components\n\u251c\u2500\u2500 modules/         # Feature-based modules (e.g., auth, posts)\n\u251c\u2500\u2500 app.dart         # \n\u2514\u2500\u2500 main.dart        # Entry point\n</code></pre>"},{"location":"architecture/#summary","title":"\ud83c\udfaf Summary","text":"<p>This architecture makes it easy to:</p> <ul> <li>Scale the app with new features</li> <li>Collaborate across large teams</li> <li>Maintain and test code reliably</li> <li>Customize or remove modules cleanly</li> </ul> <p>You can find example modules like auth and posts in the respective folders. Each one is fully isolated and demonstrates the intended Clean Modular Architecture pattern.</p>"},{"location":"contributing/","title":"\ud83e\udd1d Contributing to Flutter Clean Starter","text":"<p>Thank you for considering contributing to this project! Your contributions are highly valued.</p> <p>Whether you're fixing bugs, improving the documentation, submitting new features, or sharing ideas \u2014 you're welcome here. \u2764\ufe0f</p>"},{"location":"contributing/#guidelines","title":"\ud83d\udccb Guidelines","text":"<p>Please take a moment to review this guide before contributing.</p>"},{"location":"contributing/#project-structure","title":"\ud83e\uddf1 Project Structure","text":"<p>This project follows Clean Architecture and Modular Architecture. Make sure your changes respect the existing separation of layers (<code>domain</code>, <code>data</code>, <code>features</code>) and module structure (<code>auth</code>, <code>posts</code>, etc.).</p>"},{"location":"contributing/#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>Add tests for new features or bug fixes.</li> <li>Follow the existing pattern for <code>__tests__</code> inside each module.</li> <li>Use <code>mocktail</code> and <code>bloc_test</code> for testing where applicable.</li> </ul>"},{"location":"contributing/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>If you're adding a new feature, update or create relevant documentation in <code>/docs/</code>.</li> <li>Keep code comments clear and concise.</li> </ul>"},{"location":"contributing/#commits","title":"\ud83d\ude80 Commits","text":"<p>Follow Conventional Commits:</p> <p>Examples: <pre><code>feat(auth): add OTP support to login\nfix(posts): correct date parsing issue in detail page\ndocs(readme): improve setup instructions\n</code></pre></p> <p>\ud83d\uddc2\ufe0f Issues &amp; Discussions     \u2022   If you found a bug, open an issue.     \u2022   For questions, use GitHub Discussions or start a thread in the issue comments.</p> <p>\ud83d\udcc4 License</p> <p>By contributing, you agree that your contributions will be licensed under the MIT License.</p> <p>Thanks for helping make this project better! \u2728</p>"},{"location":"folder_structure/","title":"\ud83d\udcc1 Folder Structure","text":"<p>This Flutter project is organized with Clean Architecture and Modular Design in mind. Below is an overview of the main directories and what each one is responsible for.</p>"},{"location":"folder_structure/#root-structure","title":"\ud83d\udd1d Root Structure","text":"<pre><code>lib/\n\u251c\u2500\u2500 _core/           # App-wide core logic (DI, theming, routing, localization)\n\u251c\u2500\u2500 _shared/         # Shared logic (widgets, utilities, services, etc.)\n\u251c\u2500\u2500 modules/         # Feature-based modules (auth, posts, etc.)\n\u251c\u2500\u2500 app.dart         # App widget setup (MaterialApp.router, theming, localization, etc.)\n\u251c\u2500\u2500 main.dart        # App entry point\n</code></pre>"},{"location":"folder_structure/#lib_core","title":"\ud83d\udce6 lib/_core/","text":"<p>Core configuration and services used across the entire app. <pre><code>_core/\n\u251c\u2500\u2500 error/              # Handles cache, network, and connection-related errors\n\u251c\u2500\u2500 layout/             # App layout logic for mobile, tablet, and desktop\n\u251c\u2500\u2500 _bootstrap.dart     # Initializes libraries and modules at app startup\n\u251c\u2500\u2500 __init_module.dart  # Registers and configures all feature modules\n\u251c\u2500\u2500 app_router.dart     # Global route config, guards, and transitions (GoRouter)\n\u251c\u2500\u2500 constants.dart      # App-wide constants and static config values\n\u251c\u2500\u2500 database.dart       # Database setup and initialization (e.g., Hive, Drift)\n\u251c\u2500\u2500 di.dart             # Dependency injection setup and registration (e.g., GetIt)\n\u251c\u2500\u2500 http_client.dart    # HTTP client setup (e.g., Dio instance with interceptors)\n\u251c\u2500\u2500 network_info.dart   # Utility to check internet connectivity status\n\u2514\u2500\u2500 theme.dart          # Light and dark theme configurations\n</code></pre></p>"},{"location":"folder_structure/#lib_shared","title":"\u267b\ufe0f lib/_shared/","text":"<p>Reusable components and logic shared between modules. <pre><code>_shared/\n\u251c\u2500\u2500 blocs/              # Global BLoC or Cubit classes not tied to any specific module\n\u251c\u2500\u2500 data/               # Shared data services or models\n\u251c\u2500\u2500 domain/             # Shared use cases, entities, and contracts\n\u251c\u2500\u2500 features/           # Shared logic or partial features (non-module-specific)\n\u251c\u2500\u2500 utils/              # Helpers, extensions, formatters\n\u251c\u2500\u2500 widgets/            # Reusable UI components and custom widgets\n\u251c\u2500\u2500 shared_module.dart  # Initialization logic for shared services or state\n\u2514\u2500\u2500 shared_routes.dart  # Shared routes accessible across modules\n</code></pre></p>"},{"location":"folder_structure/#libmodules","title":"\ud83d\udd17 lib/modules/","text":"<p>Each module is feature-specific and self-contained.</p> <p>Example: auth and posts modules <pre><code>modules/\n\u251c\u2500\u2500 auth/\n\u2502   \u251c\u2500\u2500 bloc/             # BLoC related to authentication (persists throughout the app lifecycle)\n\u2502   \u251c\u2500\u2500 data/             # DTOs, models, repository implementations\n\u2502   \u251c\u2500\u2500 domain/           # Entities, use cases, repository contracts\n\u2502   \u251c\u2500\u2500 features/         # UI components, screens, and local BLoC logic\n\u2502   \u251c\u2500\u2500 __tests__/        # Unit and integration tests specific to the auth module\n\u2502   \u251c\u2500\u2500 auth_module.dart  # DI setup and initialization for auth\n\u2502   \u2514\u2500\u2500 auth_routes.dart  # Route definitions specific to auth\n\u2502\n\u251c\u2500\u2500 posts/\n\u2502   \u251c\u2500\u2500 data/\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 features/\n\u2502   \u251c\u2500\u2500 __tests__/        # Tests scoped to the posts module\n\u2502   \u251c\u2500\u2500 posts_module.dart\n\u2502   \u2514\u2500\u2500 posts_routes.dart\n</code></pre> Each module contains everything it needs to function independently.</p>"},{"location":"folder_structure/#mock-optional","title":"\ud83e\uddea mock (Optional)","text":"<p>A simple local Dart server to mock backend APIs without needing Go or Node servers.</p> <pre><code>mock/\n\u2514\u2500\u2500 server/\n    \u251c\u2500\u2500 routes/\n    \u2502   \u251c\u2500\u2500 auth.dart       # Mock auth endpoints\n    \u2502   \u2514\u2500\u2500 posts.dart      # Mock posts endpoints\n    \u2514\u2500\u2500 main.dart           # Entry file to run the mock server\n</code></pre>"},{"location":"folder_structure/#summary","title":"\ud83d\udcdd Summary","text":"<p>This structure helps achieve: \u2705 Clear separation of concerns \u2705 Modular and scalable codebase \u2705 Ease of testing and collaboration \u2705 Simplicity in adding/removing features  </p> <p>Each module can be dropped in or out without tightly coupling it to the rest of the app.</p>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":"<p>This guide will help you set up and run the Flutter Clean Starter project on your local machine. The starter is modular, cleanly structured, and supports both web and mobile platforms. You can use:  </p> <ul> <li>\ud83d\udd27 A built-in mock API (Dart)  </li> <li>\ud83e\udde9 Optional Go or Node.js APIs (linked below)</li> </ul>"},{"location":"getting_started/#prerequisites","title":"\u2705 Prerequisites","text":"<p>Before getting started, make sure you have the following installed:</p> <ul> <li>Flutter SDK (Install Flutter)</li> <li>Dart SDK (comes with Flutter)</li> <li>A device/emulator or Chrome browser for web</li> <li>Git (for cloning the repo)</li> <li>(Optional) Go and/or Node.js for backend APIs</li> </ul>"},{"location":"getting_started/#installation","title":"\ud83d\udce6 Installation","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/your-username/flutter_clean_starter.git\n</code></pre> <pre><code>cd flutter_clean_starter\n</code></pre></p> </li> <li> <p>Install Flutter dependencies: <pre><code>flutter pub get\n</code></pre></p> </li> </ol>"},{"location":"getting_started/#running-the-app","title":"\ud83d\udda5\ufe0f Running the App","text":""},{"location":"getting_started/#flutter-web-recommended-for-quick-start","title":"Flutter Web (Recommended for Quick Start)","text":"<pre><code>flutter run -d chrome\n</code></pre>"},{"location":"getting_started/#flutter-mobile","title":"Flutter Mobile","text":"<p>Ensure a device/emulator is running, then:</p> <pre><code>flutter run\n</code></pre>"},{"location":"getting_started/#option-1-use-the-built-in-mock-api-dart","title":"\ud83e\uddea Option 1: Use the Built-in Mock API (Dart)","text":"<p>This project includes a lightweight mock API to simulate backend behavior for local development.</p> <ol> <li> <p>Navigate to the mock API directory: <pre><code>cd mock\n</code></pre></p> </li> <li> <p>Install Dart dependencies: <pre><code>dart pub get\n</code></pre></p> </li> <li> <p>Run the mock server: <pre><code>dart server/main.dart\n</code></pre></p> </li> </ol> <p>The server will start on: http://localhost:8080</p> <p>The Flutter app will automatically use this mock API when no real API is configured.</p>"},{"location":"getting_started/#option-2-use-go-or-nodejs-apis-optional","title":"\ud83d\udd01 Option 2: Use Go or Node.js APIs (Optional)","text":"<p>Instead of the mock server, you can run real API servers:</p> <ul> <li>\ud83d\udc49 Go API Starter </li> <li>\ud83d\udc49 Node API Starter (in progress)</li> </ul> <p>Each backend is structured to match the same API contract used in the Flutter app.</p>"},{"location":"getting_started/#optional-feature-branch-post-module","title":"\ud83c\udf31 Optional Feature Branch: Post Module","text":"<p>The branch clean-start-with-post-module includes a full working example of a posts module (UI, domain, data, routes).</p> <p>To use it: <pre><code>git checkout clean-start-with-post-module\n</code></pre> <pre><code>flutter pub get\n</code></pre> Run the mock API: <pre><code>dart mock/server/main.dart\n</code></pre> Then launch the app: <pre><code>flutter run -d chrome\n</code></pre></p>"},{"location":"getting_started/#whats-next","title":"\ud83d\udee0\ufe0f What\u2019s Next?","text":"<ul> <li>Explore modules in /modules/auth and /modules/posts (in branch)  </li> <li>Read the Architecture documentation  </li> <li>Replace the mock API with your Go/Node backend  </li> <li>Contribute or extend with your own feature module!  </li> </ul>"},{"location":"_core/app_router/","title":"\ud83e\udded App Router","text":"<p>This file defines the centralized routing logic for the Flutter Clean Starter project using <code>go_router</code>. It handles route configuration, navigation guards based on authentication state, transitions, and the initial redirect logic.</p>"},{"location":"_core/app_router/#key-components","title":"\ud83d\udd11 Key Components","text":""},{"location":"_core/app_router/#approuter","title":"\ud83d\udd39 <code>AppRouter</code>","text":"<p>A wrapper class for initializing the <code>GoRouter</code> instance.</p> <ul> <li>Constructor: Accepts a list of <code>RouteBase</code> which defines the app's routes.</li> <li>router: The main <code>GoRouter</code> object, configured with:</li> <li><code>navigatorKey</code>: <code>rootNavigatorKey</code></li> <li><code>initialLocation</code>: <code>/</code></li> <li><code>errorPageBuilder</code>: Renders a custom 404 page on unknown routes.</li> <li><code>routes</code>: Your feature/module routes.</li> </ul> <pre><code>late final router = GoRouter(\n  navigatorKey: rootNavigatorKey,\n  initialLocation: \"/\",\n  errorPageBuilder: (_, __) =&gt; NoTransitionPage&lt;void&gt;(child: const Error404Page()),\n  debugLogDiagnostics: false,\n  routes: routes,\n);\n</code></pre>"},{"location":"_core/app_router/#route-guards","title":"\ud83d\udea6 Route Guards","text":"<p>These functions intercept navigation based on authentication status:</p>"},{"location":"_core/app_router/#authrouteguard","title":"\ud83d\udd10 authRouteGuard(...)","text":"<p>Allows access only if the user is authenticated. Otherwise, redirects to /errors/401.</p> <p><code>FutureOr&lt;String?&gt; authRouteGuard(BuildContext context, GoRouterState state)</code></p>"},{"location":"_core/app_router/#unauthrouteguard","title":"\ud83d\udeab unAuthRouteGuard(...)","text":"<p>Allows access only if the user is unauthenticated. Otherwise, redirects to the default (first) navigation route.</p> <p><code>FutureOr&lt;String?&gt; unAuthRouteGuard(BuildContext context, GoRouterState state)</code></p>"},{"location":"_core/app_router/#initialredirect","title":"\ud83e\udded initialRedirect(...)","text":"<p>Used to determine the app\u2019s initial landing route based on authentication state.</p> <ul> <li>Authenticated \u2192 first nav route</li> <li>Unauthenticated \u2192 /landing on web, /login on mobile</li> <li>Unknown \u2192 stays at / (until auth status is determined)</li> </ul> <p><code>FutureOr&lt;String?&gt; initialRedirect(BuildContext context, GoRouterState state)</code></p>"},{"location":"_core/app_router/#utilities","title":"\ud83e\udde9 Utilities","text":""},{"location":"_core/app_router/#rootnavigatorkey","title":"\ud83e\uddf7 rootNavigatorKey","text":"<p>A GlobalKey used by GoRouter to control the top-level navigator. <p><code>final rootNavigatorKey = GlobalKey&lt;NavigatorState&gt;(debugLabel: 'root');</code></p>"},{"location":"_core/app_router/#getnavroutes-and-firstnavroute","title":"\ud83e\udded getNavRoutes() and firstNavRoute()","text":"<p>Used to fetch the list of primary navigation tabs (AdaptiveDestination) and get the route of the first tab.</p> <p><code>List&lt;AdaptiveDestination&gt; getNavRoutes()</code></p> <p><code>String firstNavRoute()</code></p>"},{"location":"_core/app_router/#notes","title":"\ud83d\udccc Notes","text":"<ul> <li>This router file is designed to be modular and adaptive.</li> <li>Routing structure is cleanly separated per feature/module.</li> <li>Guards are implemented using Bloc-based auth state, allowing reactive redirects.</li> </ul>"},{"location":"_core/app_router/#related-files","title":"\ud83d\udcda Related Files","text":"<ul> <li>constants.dart: Contains DI keys and static values.</li> <li>di.dart: Registers AdaptiveDestination and AuthBloc.</li> <li>adaptive_destination.dart: Defines the structure of bottom/tab navigation destinations.</li> <li>error_404_page.dart: Custom fallback UI for unknown routes.</li> </ul>"},{"location":"_core/bootstrap/","title":"\ud83d\ude80 bootstrap.dart","text":"<p>The bootstrap.dart file is the centralized initialization entry point for the app. It sets up all the core services and prepares the application before runApp() is called.</p> <p>This is typically invoked from the main.dart file during startup.</p>"},{"location":"_core/bootstrap/#responsibilities","title":"\ud83e\udde9 Responsibilities","text":"<p>The Bootstrap.init() method handles the following tasks:</p> <ol> <li> <p>Initialize Core DI Tokens</p> <p>Registers two empty lists in the dependency injection container (DI) to hold:</p> <ul> <li>mainRouesDiKey: All route definitions.</li> <li>navTabsDiKey: Navigation tab destinations (used for adaptive layouts). <pre><code>di.registerSingleton&lt;List&lt;RouteBase&gt;&gt;([], instanceName: Constants.mainRouesDiKey);\ndi.registerSingleton&lt;List&lt;AdaptiveDestination&gt;&gt;([], instanceName: Constants.navTabsDiKey);\n</code></pre></li> </ul> </li> <li> <p>Initialize Core Services</p> <p>Calls initialization methods for essential core services:</p> <ul> <li>HttpClient.init(): Configures and registers the Dio HTTP client with interceptors.</li> <li>Database.init(): Initializes the local database (e.g., Hive).</li> <li>InitialAppData.load(): Loads any essential app-wide cached values or configs.</li> </ul> </li> <li> <p>Register Network Utilities</p> <p>Registers a lazy singleton for NetworkInfo to track internet connection status throughout the app. <pre><code>di.registerLazySingleton&lt;NetworkInfo&gt;(() =&gt; NetworkInfoImpl());\n</code></pre></p> </li> <li> <p>Initialize Feature Modules</p> <p>Delegates the initialization of all feature modules to AppModules.initBeforeRunApp(). This helps in keeping module-level setup (e.g., auth, post) separate and organized.</p> </li> <li> <p>Register Router</p> <p>After all routes have been collected and initialized by the modules, the GoRouter instance is created and registered. <pre><code>di.registerLazySingleton(() =&gt; AppRouter(routes: di.get(instanceName: Constants.mainRouesDiKey)));\n</code></pre></p> </li> </ol> <p>\u2705 Summary</p> <p>bootstrap.dart is your app\u2019s setup orchestrator. It ensures:</p> <ul> <li>All dependencies are registered</li> <li>All required services are initialized</li> <li>Routes and navigation are wired up</li> <li>The app is ready to be run</li> </ul> <p>\ud83d\udccc This structure supports modular scalability, clean architecture, and testability by isolating initialization logic from UI components.</p>"},{"location":"_core/database/","title":"\ud83d\uddc4\ufe0f database.dart","text":"<p>The database.dart file initializes and registers Hive as the local database solution used throughout the app.</p>"},{"location":"_core/database/#initialization","title":"\u2699\ufe0f Initialization","text":"<p>The Database.init() method is called in bootstrap.dart during app startup. It does two things:</p> <ol> <li>Initializes Hive using Hive.initFlutter() so it can be used in a Flutter environment.</li> <li>Registers Hive in the Dependency Injection (DI) container so it can be accessed globally via di.get(). <pre><code>class Database {\n  static init() async {\n    await Hive.initFlutter();\n    di.registerLazySingleton&lt;HiveInterface&gt;(() =&gt; Hive);\n  }\n}\n</code></pre>"},{"location":"_core/database/#usage-pattern","title":"\ud83d\udca1 Usage Pattern","text":"<p>After initialization, Hive can be accessed through the DI container anywhere in the app using: <pre><code>final hive = di&lt;HiveInterface&gt;();\n</code></pre></p>"},{"location":"_core/database/#example-caching-and-retrieving-a-user","title":"\ud83d\udce6 Example: Caching and Retrieving a User","text":"<p>Hive is commonly used to cache lightweight app data such as tokens, user sessions, or preferences. Here\u2019s how it\u2019s used in the AuthRepository:</p> <p>\u2705 Caching a User <pre><code>Future&lt;void&gt; _cacheUser(UserModel user) async {\n  try {\n    final userBox = await hive.openLazyBox(Constants.userBoxName);\n    userBox.put(Constants.cachedUserRef, user);\n  } catch (e) {\n    throw CacheException();\n  }\n}\n</code></pre> \ud83d\udd04 Retrieving a Cached User <pre><code>Future&lt;UserModel&gt; _getCachedUser() async {\n  final userBox = await hive.openLazyBox(Constants.userBoxName);\n  final user = await userBox.get(Constants.cachedUserRef);\n  if (user != null) {\n    return user;\n  } else {\n    throw CacheException();\n  }\n}\n</code></pre></p>"},{"location":"_core/database/#benefits","title":"\u2705 Benefits","text":"<ul> <li>Performance: Hive is a lightweight, fast NoSQL database perfect for local caching.</li> <li>Modularity: By registering Hive in DI, you can swap it with another local DB in the future without tightly coupling it to your feature code.</li> <li>Scalability: With box-based separation, each module can manage its own storage cleanly.</li> </ul>"},{"location":"_core/database/#related-files","title":"\ud83d\udce6 Related Files","text":"File Purpose database.dart Initializes and registers Hive via DI constants.dart Contains Hive box and key names di.dart Registers Hive as a lazy singleton auth_repository Demonstrates caching/retrieving data via Hive"},{"location":"_core/di/","title":"\ud83e\udde9 Dependency Injection (DI)","text":"<p>The Flutter Clean Starter uses <code>get_it</code> for dependency injection. This makes it easy to manage and access services, blocs, utilities, and other shared resources throughout the app in a clean and testable way.</p>"},{"location":"_core/di/#file-lib_coredidart","title":"\ud83d\udcc1 File: <code>lib/_core/di.dart</code>","text":"<p><pre><code>import 'package:get_it/get_it.dart';\n\nfinal GetIt di = GetIt.instance;\n</code></pre> This file exposes a globally available singleton instance of GetIt, referenced as di throughout the app.</p>"},{"location":"_core/di/#registering-dependencies","title":"\ud83d\udd27 Registering Dependencies","text":"<p>Dependencies are typically registered in the bootstrap.dart or init_modules.dart files, during app initialization.</p> <p>Example: Registering a singleton</p> <p><code>di.registerLazySingleton&lt;SomeService&gt;(() =&gt; SomeServiceImpl());</code></p> <ul> <li>registerLazySingleton: The object is created only when first used.</li> <li>registerSingleton: The object is created immediately and shared.</li> <li>registerFactory: A new instance is created on every retrieval.</li> </ul> <p>Named Registration</p> <p>You can optionally register dependencies with a name using instanceName: <pre><code>di.registerSingleton&lt;SomeTabController&gt;(\n  SomeTabController(),\n  instanceName: Constants.navTabsDiKey,\n);\n</code></pre> This is helpful for registering multiple instances of the same type for different purposes.</p>"},{"location":"_core/di/#accessing-dependencies","title":"\ud83e\uddd1\u200d\ud83d\udcbb Accessing Dependencies","text":"<p>Anywhere in your app (routes, widgets, blocs, services, etc.), you can retrieve a registered dependency like this:</p> <p>Example: Basic Access <pre><code>final authRepo = di&lt;AuthRepository&gt;();\n</code></pre> Example: With instanceName <pre><code>final navRoutes = di.get&lt;List&lt;AdaptiveDestination&gt;&gt;(\n  instanceName: Constants.navTabsDiKey,\n);\n</code></pre> This is used in app_router.dart to retrieve navigation tabs dynamically.</p>"},{"location":"_core/di/#why-use-di","title":"\ud83d\udd04 Why Use DI?","text":"<ul> <li>Decouples implementation from usage (e.g., blocs don\u2019t need to know how services are built).</li> <li>Improves testability by allowing mocks to be injected.</li> <li>Centralizes configuration for shared app resources like HTTP clients, local storage, theme managers, etc.</li> </ul>"},{"location":"_core/di/#related","title":"\ud83d\udcda Related","text":"<ul> <li>get_it on pub.dev</li> <li>bootstrap.dart: The main setup point for DI</li> <li>init_modules.dart: Registers feature/module-specific services</li> </ul>"},{"location":"_core/http_client/","title":"\ud83c\udf10 HTTP Client","text":"<p>The project uses Dio as the primary HTTP client for all API interactions. It is wrapped and initialized through a custom <code>HttpClient</code> class for consistent configuration and centralized request handling.</p>"},{"location":"_core/http_client/#file-lib_corehttp_clientdart","title":"\ud83d\udcc1 File: <code>lib/_core/http_client.dart</code>","text":"<pre><code>class HttpClient {\n  static Future&lt;void&gt; init() async {\n    Dio dio = Dio(BaseOptions(baseUrl: Constants.apiBaseUrl));\n    ...\n    di.registerLazySingleton(() =&gt; dio);\n  }\n}\n</code></pre> <p>This class configures and registers Dio with necessary interceptors and a base URL, and integrates it into the app\u2019s dependency injection container (di).</p>"},{"location":"_core/http_client/#initialization","title":"\ud83d\udd27 Initialization","text":"<p>The HttpClient.init() method is called in bootstrap.dart during app startup.</p> <p>It does the following:</p> <ol> <li>Sets a base URL from Constants.apiBaseUrl</li> <li>Adds interceptors for:<ul> <li>Automatically attaching authorization tokens</li> <li>Logging requests</li> <li>Handling response and error logic</li> </ul> </li> <li>Registers Dio in DI so it can be used anywhere in the app via di()"},{"location":"_core/http_client/#interceptors","title":"\ud83d\udee1\ufe0f Interceptors","text":""},{"location":"_core/http_client/#request-interceptor","title":"\ud83d\udd11 Request Interceptor","text":"<p>Automatically attaches the bearer token from Hive storage (if present): <pre><code>final tokenBox = await Hive.openLazyBox(Constants.tokenBoxName);\nfinal token = await tokenBox.get(Constants.cachedTokenRef);\noptions.headers['authorization'] = \"Bearer $token\";\n</code></pre> Also logs the outgoing request: <pre><code>debugPrint(\"request: ${options.uri}\");\n</code></pre></p>"},{"location":"_core/http_client/#response-interceptor","title":"\u2705 Response Interceptor","text":"<p>Only passes successful responses (status code 2xx). Others are converted to a ServerException (placeholder for now): <pre><code>if (response.statusCode! &gt;= 200 || response.statusCode! &lt; 300) {\n  return handler.next(response);\n} else {\n  response = ServerException() as Response;\n  return handler.next(response);\n}\n</code></pre></p>"},{"location":"_core/http_client/#error-interceptor","title":"\u274c Error Interceptor","text":"<p>Logs the error and continues the chain: <pre><code>print('onError: =&gt; $e');\n</code></pre></p>"},{"location":"_core/http_client/#accessing-dio-anywhere","title":"\ud83e\uddd1\u200d\ud83d\udcbb Accessing Dio Anywhere","text":"<p>Because Dio is registered in the DI container, you can retrieve it from anywhere using: <pre><code>final dio = di&lt;Dio&gt;();\n</code></pre></p> <p>\u2e3b</p>"},{"location":"_core/http_client/#related-files","title":"\ud83d\udce6 Related Files","text":"File Purpose constants.dart Stores the base URL and Hive box/token keys di.dart Registers Dio as a lazy singleton bootstrap.dart Calls HttpClient.init() during app startup error/exceptions.dart Contains custom exception classes like ServerException"},{"location":"_core/http_client/#testing-tips","title":"\ud83e\uddea Testing Tips","text":"<ul> <li>You can replace the real Dio instance in tests with a mock: <pre><code>di.unregister&lt;Dio&gt;();\ndi.registerLazySingleton&lt;Dio&gt;(() =&gt; MockDio());\n</code></pre></li> </ul> <p>\ud83d\udea7 Improvements To Consider</p> <ul> <li>Use pretty_dio_logger for better request/response logs during development.</li> </ul>"},{"location":"_core/init_modules/","title":"\ud83e\udde9 init_modules.dart","text":"<p>The init_modules.dart file orchestrates the registration of feature modules in the app, ensuring they are initialized at the right time based on whether they require a BuildContext.</p>"},{"location":"_core/init_modules/#purpose","title":"\ud83e\udde0 Purpose","text":"<p>Flutter Clean Starter follows modular design, and this file centralizes the initialization of all app modules (like AuthModule, PostModule, SharedModule, etc.).</p> <p>Modules are registered in two phases:</p> <p>\u2705 initBeforeRunApp()</p> <ul> <li>Called before runApp()</li> <li>Used to initialize modules that do not require BuildContext</li> <li>Example: setting up routes, services, or BLoC providers</li> </ul> <p>\u2705 initAfterRunApp(BuildContext context)</p> <ul> <li>Called after runApp(), when a BuildContext is available</li> <li>Used to initialize modules that need access to UI context (e.g., for navigation tabs)</li> <li>Ensures a context-safe modular configuration</li> </ul>"},{"location":"_core/init_modules/#code-breakdown","title":"\ud83d\udce6 Code Breakdown","text":"<pre><code>class AppModules {\n  static void initBeforeRunApp() {\n    registerAuthModule();\n    registerSharedModule();\n    registerPostModule();\n  }\n\n  static void initAfterRunApp(BuildContext context) {\n    var navTabs = di&lt;List&lt;AdaptiveDestination&gt;&gt;(instanceName: Constants.navTabsDiKey);\n    navTabs.clear();\n\n    registerAuthModuleWithContext(context);\n    registerSharedModuleWithContext(context);\n    registerPostModuleWithContext(context);\n\n    navTabs.sort();\n  }\n}\n</code></pre>"},{"location":"_core/init_modules/#modular-lifecycle","title":"\ud83d\udccc Modular Lifecycle","text":"Phase Method Requires <code>BuildContext</code> Example Use Cases Pre-run <code>initBeforeRunApp()</code> \u274c No Register routes, services Post-run <code>initAfterRunApp(context)</code> \u2705 Yes Register UI elements like tabs"},{"location":"_core/init_modules/#why-this-pattern","title":"\ud83d\udca1 Why This Pattern?","text":"<ul> <li>Separation of concerns: Keeps pre-run and post-run registrations clean and isolated</li> <li>Context safety: Prevents premature access to BuildContext</li> <li>Extendability: Easy to add new modules without touching the core bootstrap logic</li> </ul>"},{"location":"_core/init_modules/#example-modules","title":"\ud83e\udde9 Example Modules","text":"<p>Each module typically has two registration functions: <pre><code>// Called before runApp\nvoid registerAuthModule();\n\n// Called after runApp with BuildContext\nvoid registerAuthModuleWithContext(BuildContext context);\n</code></pre> This keeps all logic related to a module encapsulated, following good Clean Architecture practices.</p>"},{"location":"_core/init_modules/#related-files","title":"\ud83d\udce6 Related Files","text":"File Purpose init_modules.dart Initializes modules before/after app starts auth_module.dart Registers Auth-related routes and tabs post_module.dart Registers Post-related routes and tabs shared_module.dart Shared widgets/utils/modules registration di.dart Registers dependencies via GetIt constants.dart Holds DI keys for tab/routing management"},{"location":"_core/overview/","title":"\ud83e\udde0 Core Overview","text":"<p>The /lib/_core directory provides foundational building blocks and global configurations used across the entire Flutter application. It ensures a clear separation of concerns, reusability, and centralized management for features like routing, dependency injection, theming, localization, and networking.</p> <p>The goal is to keep core logic independent of individual modules, while offering global services and bootstrapping mechanisms used app-wide.</p>"},{"location":"_core/overview/#folder-structure","title":"\ud83e\uddf1 Folder Structure","text":"<pre><code>_core/\n\u251c\u2500\u2500 error/            # Custom error handling (e.g., network/cache errors)\n\u251c\u2500\u2500 layout/           # Layout builders for adaptive design (mobile/tablet/desktop)\n\u251c\u2500\u2500 app_router.dart   # Global route config, guards, transitions\n\u251c\u2500\u2500 bootstrap.dart    # App bootstrap: initializes services and modules\n\u251c\u2500\u2500 constants.dart    # Global constants\n\u251c\u2500\u2500 database.dart     # Database setup (Hive or others)\n\u251c\u2500\u2500 di.dart           # Dependency injection configuration (GetIt)\n\u251c\u2500\u2500 http_client.dart  # Central HTTP client setup (e.g., Dio)\n\u251c\u2500\u2500 network_info.dart # Check for internet connectivity\n\u251c\u2500\u2500 theme.dart        # Light/dark theme configuration\n</code></pre>"},{"location":"_core/overview/#responsibilities","title":"\ud83d\udccc Responsibilities","text":"File / Folder Purpose <code>bootstrap.dart</code> Entry point before <code>runApp</code>. Initializes DI, database, modules, and any pre-run setup. <code>__init_modules.dart</code> Central place to register all feature modules (auth, posts, etc.). <code>app_router.dart</code> Sets up GoRouter, route guards, and page transitions globally. <code>di.dart</code> Registers global dependencies (like Dio, shared prefs, network utils, etc.). <code>database.dart</code> Configures and initializes local databases (Hive, etc.). <code>constants.dart</code> Defines app-wide static values and keys (e.g., token keys, base URLs). <code>http_client.dart</code> A wrapper around Dio or other HTTP clients for consistent API handling. <code>network_info.dart</code> Utility to check internet connection status. <code>theme.dart</code> Sets up app-wide themes including color schemes and text styles. <code>layout/</code> Offers responsive layout builders to handle multiple screen types (mobile/tablet/desktop). <code>error/</code> Contains error handling for network failures, caching issues, or general exceptions."},{"location":"_core/overview/#why-it-matters","title":"\ud83d\udca1 Why It Matters","text":"<ul> <li>Encourages centralized configuration and reduces redundancy.</li> <li>Makes it easier to scale by isolating startup logic and global services.</li> <li>Promotes testability and maintainability by keeping core services reusable across modules.</li> <li>Acts as the glue between the app\u2019s lifecycle and the feature modules.</li> </ul>"},{"location":"_core/theme/","title":"\ud83c\udfa8 App Theming","text":"<p>This project uses flex_color_scheme for consistent and customizable light and dark themes. Runtime theme switching is handled with flutter_bloc through a ThemeModeCubit, and preferences are persisted using Hive.</p>"},{"location":"_core/theme/#static-themes-light-dark","title":"\ud83c\udf08 Static Themes (light &amp; dark)","text":"<p>Defined in theme.dart using FlexThemeData.light() and FlexThemeData.dark():</p> <pre><code>final ThemeData lightTheme = FlexThemeData.light(\n  scheme: FlexScheme.deepBlue,\n  ...\n);\n\nfinal ThemeData darkTheme = FlexThemeData.dark(\n  scheme: FlexScheme.deepBlue,\n  ...\n);\n</code></pre>"},{"location":"_core/theme/#features","title":"\u2728 Features","text":"<ul> <li>Based on Material Design 3</li> <li>Custom sub-theme configurations (inputs, dropdowns, navigation rail, etc.)</li> <li>Shared visual density and Cupertino overrides</li> <li>Uses FlexColorScheme.comfortablePlatformDensity for consistency across devices</li> </ul>"},{"location":"_core/theme/#dynamic-theme-mode","title":"\ud83c\udf13 Dynamic Theme Mode","text":""},{"location":"_core/theme/#thememodecubit","title":"ThemeModeCubit","text":"<p>Defined in _shared/blocs/theme_mode_cubit.dart, this cubit allows switching between light, dark, and system modes at runtime and persists the setting with Hive. <pre><code>class ThemeModeCubit extends Cubit&lt;ThemeMode&gt; {\n...\n}\n</code></pre></p>"},{"location":"_core/theme/#responsibilities","title":"\ud83d\udca1 Responsibilities","text":"Method Description <code>darkMode()</code> Switches to dark mode and saves it in Hive <code>lightMode()</code> Switches to light mode and saves it in Hive <code>systemMode()</code> Switches to system mode and saves it in Hive <code>loadTheme()</code> Loads the theme from Hive and emits it"},{"location":"_core/theme/#integration-in-appdart","title":"\ud83d\uddbc\ufe0f Integration in app.dart","text":"<p>In the root app.dart file, the current ThemeMode is applied via BlocBuilder: <pre><code>BlocBuilder&lt;ThemeModeCubit, ThemeMode&gt;(\n    builder: (context, themeMode) {\n        return MaterialApp.router(\n        theme: lightTheme,\n        darkTheme: darkTheme,\n        themeMode: themeMode, // Controlled by ThemeModeCubit\n        ...\n        );\n    },\n)\n</code></pre> This ensures seamless theme switching without restarting the app.</p>"},{"location":"_core/theme/#toggle-button","title":"\ud83e\uddee Toggle Button","text":"<p>Located in _shared/widgets/theme_mode_button.dart, this widget allows users to toggle between light and dark modes manually: <pre><code>return IconButton(\n    tooltip: context.tr('layoutPage.changeTheme'),\n    constraints: BoxConstraints(minWidth: radius ?? 44, minHeight: radius ?? 44),\n    onPressed: () {\n        if (Theme.of(context).brightness == Brightness.dark) {\n            context.read&lt;ThemeModeCubit&gt;().lightMode();\n        } else {\n            context.read&lt;ThemeModeCubit&gt;().darkMode();\n        }\n    },\n    icon: Icon(\n        Theme.of(context).brightness == Brightness.dark\n            ? Icons.light_mode_outlined\n            : Icons.dark_mode_outlined,\n    ),\n);\n</code></pre> \ud83d\udee0\ufe0f This button updates automatically based on the current brightness and can be placed in the app bar or settings screen.</p>"},{"location":"_core/theme/#related-files","title":"\ud83d\udce6 Related Files","text":"File Purpose <code>theme.dart</code> Defines static <code>lightTheme</code> and <code>darkTheme</code> <code>_shared/blocs/theme_mode_cubit.dart</code> BLoC cubit for managing the active <code>ThemeMode</code> <code>_shared/widgets/theme_mode_button.dart</code> UI toggle button for switching themes <code>app.dart</code> Applies the current theme mode via <code>MaterialApp.router</code> <code>utils/global_utils.dart</code> (optional) Syncs theme mode for web if needed"},{"location":"modules/auth/","title":"\ud83d\udd10 Authentication Module","text":"<p>This module handles all user authentication logic using a clean architecture approach, keeping core business rules isolated from external dependencies.</p>"},{"location":"modules/auth/#domain-layer","title":"\ud83e\udde0 Domain Layer","text":"<p>Defines core authentication logic, independent of any frameworks or data sources.</p>"},{"location":"modules/auth/#userdart","title":"user.dart","text":"<p>Entity representing the authenticated user.</p> <pre><code>    class User extends Equatable {\n        final String id, firstName, lastName, phone, email;\n        final bool isEmailVerified;\n        final List&lt;String&gt; roles;\n\n        const User({\n            required this.id,\n            required this.firstName,\n            required this.lastName,\n            required this.phone,\n            required this.email,\n            required this.isEmailVerified,\n            required this.roles,\n        });\n\n        static const empty = User(\n            id: '-', firstName: '-', lastName: '-', phone: '-',\n            email: '-', isEmailVerified: false, roles: [],\n        );\n\n        @override\n        List&lt;Object&gt; get props =&gt; [id, firstName, lastName, phone, email, isEmailVerified, roles];\n    }\n</code></pre>"},{"location":"modules/auth/#auth_repositorydart","title":"auth_repository.dart","text":"<p>Abstract contract for authentication operations.</p> <pre><code>abstract class AuthRepository {\n  Stream&lt;User&gt; getUserStream();\n  void dispose();\n\n  Future&lt;Either&lt;Failure, void&gt;&gt; isAuthenticated();\n  Future&lt;Either&lt;Failure, void&gt;&gt; login({required String email, required String password});\n  Future&lt;Either&lt;Failure, void&gt;&gt; logout();\n  Future&lt;Either&lt;Failure, User?&gt;&gt; getUser();\n  Future&lt;Either&lt;Failure, void&gt;&gt; register({\n    required String firstName,\n    required String lastName,\n    required String phone,\n    required String email,\n    required String password,\n    required bool iAgree,\n  });\n}\n</code></pre>"},{"location":"modules/auth/#auth_usecasesdart","title":"auth_usecases.dart","text":"<p>Use cases that interact with AuthRepository.</p> <pre><code>class AuthUsecases {\n  final AuthRepository repo;\n  AuthUsecases(this.repo);\n\n  Future&lt;Either&lt;Failure, void&gt;&gt; isAuthenticated() =&gt; repo.isAuthenticated();\n  Stream&lt;User&gt; getUserStream() =&gt; repo.getUserStream();\n  Future&lt;Either&lt;Failure, void&gt;&gt; logout() =&gt; repo.logout();\n  void dispose() =&gt; repo.dispose();\n}\n</code></pre>"},{"location":"modules/auth/#data-layer","title":"\ud83d\udce6 Data Layer","text":"<p>The data layer provides the concrete implementation of AuthRepository and bridges the domain layer with external systems (network and local storage).</p> <p>It uses:</p> <ul> <li>\ud83d\udef0\ufe0f Dio for network calls</li> <li>\ud83d\udce6 Hive for local caching</li> <li>\ud83d\udd01 RxDart (BehaviorSubject) for user state streaming</li> </ul>"},{"location":"modules/auth/#authrepositoryimpl","title":"\ud83d\udd27 AuthRepositoryImpl","text":"<p>Implements the AuthRepository contract using Dio, Hive, and network info. Key responsibilities:</p> Method Description <code>login</code> Authenticates via <code>/users/login</code>, caches token/user, updates stream <code>register</code> Sends registration request to <code>/users</code> <code>getUser</code> Fetches user from API, updates user stream <code>isAuthenticated</code> Checks user stream or loads from cache <code>logout</code> Clears Hive boxes and resets user stream <code>getUserStream()</code> Returns reactive stream of current <code>User</code> <code>dispose()</code> Closes the stream <p>\ud83d\uddc3\ufe0f Local Helpers:</p> <ul> <li>_cacheToken, _cacheUser, _getCachedUser, _clearCache</li> <li>_mapError: maps exceptions to domain Failure objects</li> </ul> Full Implementation: <code>auth_repository_impl.dart</code> <pre><code>class AuthRepositoryImpl implements AuthRepository {\n  final Dio dio;\n  final HiveInterface hive;\n  final NetworkInfo networkInfo;\n  final _userController = BehaviorSubject&lt;User&gt;();\n\n  AuthRepositoryImpl({required this.dio, required this.hive, required this.networkInfo});\n\n  @override\n  Stream&lt;User&gt; getUserStream() =&gt; _userController.stream;\n\n  @override\n  Future&lt;Either&lt;Failure, void&gt;&gt; isAuthenticated() async {\n    try {\n      if (_userController.hasValue) return Right(null);\n      final user = await _getCachedUser();\n      _userController.add(user);\n      return Right(null);\n    } catch (_) {\n      _userController.add(User.empty);\n      return Left(CacheFailure(\"Failed to load cached user\"));\n    }\n  }\n\n  @override\n  Future&lt;Either&lt;Failure, void&gt;&gt; login({required String email, required String password}) async {\n    try {\n      final res = await dio.post('/users/login', data: {\"email\": email, \"password\": password});\n      final token = res.data['data']['token'];\n      if (token == null) return Left(ServerFailure(\"Invalid response\"));\n\n      await _cacheToken(token);\n      final user = await _getUser();\n      await _cacheUser(user);\n      _userController.add(user);\n      return Right(null);\n    } catch (e) {\n      return Left(_mapError(e));\n    }\n  }\n\n  @override\n  Future&lt;Either&lt;Failure, void&gt;&gt; register({ ... }) async {\n    try {\n      await dio.post('/users', data: { ... });\n      return Right(null);\n    } catch (e) {\n      return Left(_mapError(e));\n    }\n  }\n\n  @override\n  Future&lt;Either&lt;Failure, User?&gt;&gt; getUser() async {\n    try {\n      final user = await _getUser();\n      _userController.add(user);\n      return Right(user);\n    } catch (e) {\n      return Left(_mapError(e));\n    }\n  }\n\n  @override\n  Future&lt;Either&lt;Failure, void&gt;&gt; logout() async {\n    try {\n      await _clearCache();\n      _userController.add(User.empty);\n      return Right(null);\n    } catch (_) {\n      return Left(CacheFailure(\"Failed to clear cache\"));\n    }\n  }\n\n  @override\n  void dispose() =&gt; _userController.close();\n\n  // Helpers\n  Future&lt;UserModel&gt; _getUser() async =&gt;\n      UserModel.fromJson((await dio.get('/users/me')).data['data']);\n\n  Future&lt;UserModel&gt; _getCachedUser() async =&gt;\n      await hive.openLazyBox('userBox').then((b) =&gt; b.get('cachedUser') ?? (throw CacheException()));\n\n  Future&lt;void&gt; _cacheToken(String token) async =&gt;\n      await hive.openLazyBox('tokenBox').then((b) =&gt; b.put('cachedToken', token));\n\n  Future&lt;void&gt; _cacheUser(UserModel user) async =&gt;\n      await hive.openLazyBox('userBox').then((b) =&gt; b.put('cachedUser', user));\n\n  Future&lt;void&gt; _clearCache() async {\n    await hive.openLazyBox('userBox').then((b) =&gt; b.clear());\n    await hive.openLazyBox('tokenBox').then((b) =&gt; b.clear());\n  }\n\n  Failure _mapError(dynamic e) {\n    if (e is DioException) return ServerFailure(DioExceptions.fromDioError(e).toString());\n    if (e is CacheException) return CacheFailure(\"Caching failed\");\n    return ServerFailure(\"Unexpected error\");\n  }\n}\n</code></pre>"},{"location":"modules/auth/#usermodel","title":"\ud83d\udc64 UserModel","text":"<p>A Hive-compatible, JSON-deserializable implementation of the domain User. Used for: \u2022 parsing /users/me API response \u2022 local caching with Hive</p> <pre><code>@HiveType(typeId: 1)\n@JsonSerializable(createToJson: false)\nclass UserModel extends User {\n    @HiveField(0) @JsonKey(name: 'id') final String id;\n    @HiveField(1) @JsonKey(name: 'firstName') final String firstName;\n    @HiveField(2) @JsonKey(name: 'lastName') final String lastName;\n    @HiveField(3) @JsonKey(name: 'phone') final String phone;\n    @HiveField(4) @JsonKey(name: 'email') final String email;\n    @HiveField(5) @JsonKey(name: 'isEmailVerified', defaultValue: false) final bool isEmailVerified;\n    @HiveField(6) @JsonKey(name: 'roles') final List&lt;String&gt; roles;\n\n    const UserModel(\n        this.id, this.firstName, this.lastName,\n        this.phone, this.email, this.isEmailVerified, this.roles\n    ) : super(\n        id: id, firstName: firstName, lastName: lastName,\n        phone: phone, email: email, isEmailVerified: isEmailVerified, roles: roles);\n\n    factory UserModel.fromJson(Map&lt;String, dynamic&gt; json) =&gt; \\_$UserModelFromJson(json);\n}\n</code></pre>"},{"location":"modules/auth/#global-authentication-bloc","title":"\ud83d\udd10 Global Authentication Bloc","text":"<p>Unlike other feature-specific BLoCs, the AuthBloc is a globally scoped bloc responsible for managing the authenticated user and session status. It persists throughout the entire app lifecycle.</p> <p>This bloc listens to a User stream exposed by the AuthRepository and emits high-level authentication states.</p>"},{"location":"modules/auth/#path-modulesauthblocauth_blocdart","title":"\ud83d\udcc1 Path: modules/auth/bloc/auth_bloc.dart","text":"<p>Auth Status Enum <pre><code>enum AuthStatus {\n  unknown,\n  authenticated,\n  unauthenticated,\n  unverified,\n}\n</code></pre></p> <p>AuthState <pre><code>class AuthState extends Equatable {\n  final AuthStatus status;\n  final User user;\n\n  const AuthState({\n    this.status = AuthStatus.unknown,\n    this.user = User.empty,\n  });\n\n  AuthState copyWith({AuthStatus? status, User? user}) =&gt; AuthState(\n    status: status ?? this.status,\n    user: user ?? this.user,\n  );\n\n  @override\n  List&lt;Object&gt; get props =&gt; [status, user];\n}\n</code></pre></p> <p>Auth Events <pre><code>abstract class AuthEvent extends Equatable {\n  const AuthEvent();\n\n  @override\n  List&lt;Object&gt; get props =&gt; [];\n}\n\nclass AppLoaded extends AuthEvent {}\n\nclass AuthStatusSubscriptionRequested extends AuthEvent {}\n\nclass AuthLogoutRequested extends AuthEvent {}\n</code></pre> AuthBloc Overview <pre><code>class AuthBloc extends Bloc&lt;AuthEvent, AuthState&gt; {\n  final AuthUsecases _userUsecase;\n\n  AuthBloc({required AuthUsecases userUsecase})\n      : _userUsecase = userUsecase,\n        super(const AuthState()) {\n    on&lt;AppLoaded&gt;(_appLoaded);\n    on&lt;AuthStatusSubscriptionRequested&gt;(_onAuthSubscriptionRequested);\n    on&lt;AuthLogoutRequested&gt;(_onAuthLogoutRequested);\n  }\n\n  Future&lt;void&gt; _appLoaded(...) async {\n    await _userUsecase.isAuthenticated();\n  }\n\n  Future&lt;void&gt; _onAuthSubscriptionRequested(...) async {\n    await _userUsecase.isAuthenticated();\n    await emit.forEach&lt;User&gt;(\n      _userUsecase.getUserStream(),\n      onData: (user) =&gt; user == User.empty\n        ? state.copyWith(status: AuthStatus.unauthenticated)\n        : state.copyWith(status: AuthStatus.authenticated, user: user),\n      onError: (_, __) =&gt; state.copyWith(status: AuthStatus.unauthenticated),\n    );\n  }\n\n  void _onAuthLogoutRequested(...) {\n    _userUsecase.logout();\n  }\n\n  @override\n  Future&lt;void&gt; close() {\n    _userUsecase.dispose();\n    return super.close();\n  }\n}\n</code></pre></p> <p>\ud83e\udde9 Bloc Registration</p> <p>The AuthBloc is registered globally via GetIt in auth_module.dart: <pre><code>di.registerLazySingleton(\n  () =&gt; AuthBloc(userUsecase: di())..add(AuthStatusSubscriptionRequested()),\n);\n</code></pre> This dispatch ensures the bloc begins listening to authentication status as soon as the app starts.</p>"},{"location":"modules/auth/#global-injection-in-app","title":"\ud83c\udf0d Global Injection in App","text":"<p>Inside app.dart, AuthBloc is injected into the root widget using MultiBlocProvider, ensuring it\u2019s available app-wide: <pre><code>class App extends StatelessWidget {\n  const App({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiBlocProvider(\n      providers: [\n        BlocProvider&lt;ThemeModeCubit&gt;(create: (context) =&gt; di()),\n        BlocProvider&lt;AuthBloc&gt;(create: (context) =&gt; di()),\n      ],\n      child: const AppView(),\n    );\n  }\n}\n</code></pre></p> <p>\u2705 This global architecture ensures that:</p> <ul> <li>User state is accessible anywhere in the app.</li> <li>Authentication state changes (login, logout, load from cache) automatically update UI and route protections.</li> <li>Lifecycle of AuthBloc matches the app lifecycle \u2014 initialized on startup and disposed only when the app exits.</li> </ul>"},{"location":"modules/auth/#features-layer","title":"\ud83c\udfa8 Features Layer","text":"<p>The features/ directory holds UI-related logic and presentation for the authentication module. It is organized into feature-specific subfolders:</p> <pre><code>features/\n\u251c\u2500\u2500 login/       # Login screen UI and its BLoC\n\u251c\u2500\u2500 register/    # Sign up screen UI and its BLoC\n\u2514\u2500\u2500 profile/     # Profile screen UI\n</code></pre>"},{"location":"modules/auth/#login-flow-example","title":"\ud83d\udd10 Login Flow Example","text":""},{"location":"modules/auth/#featuresloginbloclogin_blocdart","title":"features/login/bloc/login_bloc.dart","text":"<p>Handles login logic by invoking the AuthUsecases.login(...) method and emitting states based on the result.</p> <pre><code>class LoginBloc extends Bloc&lt;LoginEvent, LoginState&gt; {\n  final AuthUsecases _authUsecases;\n\n  LoginBloc({required AuthUsecases authUsecases})\n      : _authUsecases = authUsecases,\n        super(LoginInitial()) {\n    on&lt;LoginSubmitted&gt;(_onSubmitted);\n  }\n\n  Future&lt;void&gt; _onSubmitted(\n    LoginSubmitted event,\n    Emitter&lt;LoginState&gt; emit,\n  ) async {\n    emit(LoginLoading());\n    var result = await _authUsecases.login(\n      email: event.email,\n      password: event.password,\n    );\n    emit(result.fold(\n      (error) =&gt; LoginFailure(error: error.getMessage()),\n      (_) =&gt; LoginSuccess(),\n    ));\n  }\n}\n</code></pre>"},{"location":"modules/auth/#featuresloginpagelogin_pagedart","title":"features/login/page/login_page.dart","text":"<p>Wraps the login form with a BlocProvider and injects LoginBloc from the dependency injector (di()).</p> <pre><code>class LoginPage extends StatelessWidget {\n  const LoginPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: BlocProvider&lt;LoginBloc&gt;(\n        create: (context) =&gt; di(),\n        child: const Center(child: LoginForm()),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"modules/auth/#featuresloginwidgetslogin_buttondart","title":"features/login/widgets/login_button.dart","text":"<p>Button that triggers the login submission after validating form data:</p> <pre><code>BlocBuilder&lt;LoginBloc, LoginState&gt;(\n  builder: (context, state) {\n    final isLoading = state is LoginLoading;\n    return FilledButton(\n      onPressed: !isLoading\n          ? () {\n              if (formKey.currentState?.saveAndValidate() ?? false) {\n                context.read&lt;LoginBloc&gt;().add(LoginSubmitted(\n                  email: formKey.currentState?.value['email'],\n                  password: formKey.currentState?.value['password'],\n                ));\n              }\n            }\n          : null,\n      child: isLoading\n          ? const CircularProgressIndicator()\n          : Text(context.tr(\"loginPage.signIn\")),\n    );\n  },\n);\n</code></pre>"},{"location":"modules/auth/#module-registration","title":"\ud83e\udde9 Module Registration","text":""},{"location":"modules/auth/#auth_moduledart","title":"\ud83e\uddf1 auth_module.dart","text":"<p>This file is responsible for registering all dependencies related to the auth module using GetIt.</p> <pre><code>Future&lt;void&gt; registerAuthModule() async {\n  // Hive Adapters\n  di&lt;HiveInterface&gt;().registerAdapter&lt;UserModel&gt;(UserModelAdapter());\n\n  // Repository &amp; Usecases\n  di.registerLazySingleton&lt;AuthRepository&gt;(\n    () =&gt; AuthRepositoryImpl(dio: di(), hive: di(), networkInfo: di()),\n  );\n  di.registerLazySingleton&lt;AuthUsecases&gt;(() =&gt; AuthUsecases(di()));\n\n  // Global AuthBloc\n  di.registerLazySingleton(\n    () =&gt; AuthBloc(userUsecase: di())..add(AuthStatusSubscriptionRequested()),\n  );\n\n  // Feature Blocs\n  di.registerFactory(() =&gt; LoginBloc(authUsecases: di()));\n  di.registerFactory(() =&gt; RegisterBloc(authUsecases: di()));\n\n  // Routes\n  di&lt;List&lt;RouteBase&gt;&gt;(instanceName: Constants.mainRouesDiKey)\n      .addAll(authRoutes());\n}\n</code></pre>"},{"location":"modules/auth/#navigation-tabs","title":"\ud83e\udded Navigation Tabs","text":"<p>Some auth features like Profile are available as tabs in adaptive layouts. Tabs are injected via registerAuthModuleWithContext, which uses BuildContext to access localized labels.</p> <pre><code>void registerAuthModuleWithContext(BuildContext context) {\n  final navTabs = di&lt;List&lt;AdaptiveDestination&gt;&gt;(\n    instanceName: Constants.navTabsDiKey,\n  );\n  navTabs.addAll(getAuthNavTabs(context));\n}\n</code></pre>"},{"location":"modules/auth/#auth_routesdart","title":"\ud83d\uddc2\ufe0f auth_routes.dart","text":"<p>Defines all routes and navigation tabs for the auth module.</p> <pre><code>List&lt;GoRoute&gt; authRoutes() {\n  return [\n    GoRoute(\n      path: \"/login\",\n      redirect: unAuthRouteGuard,\n      pageBuilder: (_, __) =&gt; const FadeTransitionPage(child: LoginPage()),\n    ),\n    GoRoute(\n      path: \"/register\",\n      redirect: unAuthRouteGuard,\n      pageBuilder: (_, __) =&gt; const FadeTransitionPage(child: RegisterPage()),\n    ),\n    GoRoute(\n      path: \"/profile\",\n      redirect: authRouteGuard,\n      pageBuilder: (_, __) =&gt; const FadeTransitionPage(child: ProfilePage()),\n    ),\n  ];\n}\n</code></pre>"},{"location":"modules/auth/#getauthnavtabs","title":"\ud83e\udded getAuthNavTabs","text":"<p>Defines tabs to be injected into the adaptive layout.</p> <pre><code>List&lt;AdaptiveDestination&gt; getAuthNavTabs(BuildContext context) {\n  return &lt;AdaptiveDestination&gt;[\n    AdaptiveDestination(\n      title: context.tr('layoutPage.profile'),\n      icon: Icons.person,\n      route: '/profile',\n      navTab: AuthNavTab.profile,\n      order: 30,\n    ),\n  ];\n}\n</code></pre> <p>\u2705 Summary</p> <p>The auth module is a fully isolated feature that follows clean architecture principles with clearly defined layers:</p> <ul> <li>Domain Layer defines the core business logic and contracts (entities, usecases, repositories).</li> <li>Data Layer implements those contracts using external systems like APIs and local storage.</li> <li>Global Bloc (AuthBloc) listens to authentication state changes and provides app-wide reactive auth state.</li> <li>Features Layer contains UI-specific logic such as login, register, and profile screens with their own BLoCs.</li> <li>Modular Registration allows the module to be independently initialized and plugged into navigation and DI.</li> </ul> <p>This structure ensures:</p> <p>\u2714\ufe0f Easy testability and mockability \u2714\ufe0f Scalable and maintainable codebase \u2714\ufe0f Independent development and replacement of auth flows \u2714\ufe0f Centralized user session management via AuthBloc \u2714\ufe0f Contextual tab and route registration with GoRouter  </p> <p>This modular approach empowers teams to build and scale large apps while keeping features decoupled and cohesive.</p>"},{"location":"modules/overview/","title":"Modules Overview","text":"<p>This directory contains the modular components of the application, organized by feature or shared functionality. Each module encapsulates its own dependencies, state management, UI, and business logic to promote scalability and maintainability.</p>"},{"location":"modules/overview/#structure","title":"Structure","text":"<ul> <li> <p>shared.md   Contains reusable components, widgets, BLoCs/Cubits, utilities, and services shared across multiple modules or the entire app.</p> </li> <li> <p>auth.md   Handles all authentication-related features such as login, registration, session management, and user profile.</p> </li> <li> <p>post.md   Manages the post feature, including creating, updating, listing, and displaying posts.</p> </li> </ul>"},{"location":"modules/overview/#purpose","title":"Purpose","text":"<p>The modular approach allows:</p> <ul> <li>Clear separation of concerns between different parts of the app.</li> <li>Easier testing and independent development of features.</li> <li>Simplified dependency injection and service registration.</li> <li>Better code organization and reusability.</li> </ul>"},{"location":"modules/overview/#initialization-lifecycle","title":"Initialization Lifecycle","text":"<p>Modules are initialized in two phases:</p> <ol> <li> <p>Before App Run    Registers core services, repositories, and non-UI dependencies.</p> </li> <li> <p>After App Run    Registers UI-related components requiring <code>BuildContext</code> (e.g., navigation tabs, theme setup).</p> </li> </ol> <p>The registration logic is centralized in <code>init_modules.dart</code> to streamline module setup.</p> <p>Refer to each module's individual documentation (<code>auth.md</code>, <code>post.md</code>, <code>shared.md</code>) for detailed information about its structure, responsibilities, and usage.</p>"},{"location":"modules/shared/","title":"Shared Module","text":"<p>The <code>shared</code> module contains functionality, data models, utilities, widgets, and BLoCs that are reused across multiple feature modules in the application. It acts as the common ground for cross-cutting concerns and shared logic.</p>"},{"location":"modules/shared/#structure","title":"Structure","text":""},{"location":"modules/shared/#1-blocs","title":"1. Blocs","text":"<ul> <li>Contains non-feature-specific or widely used BLoCs/Cubits, such as:</li> <li><code>ThemeModeCubit</code> for theme management across the app.</li> </ul>"},{"location":"modules/shared/#2-data-layer","title":"2. Data Layer","text":"<ul> <li>Houses shared data models and domain abstractions that multiple modules use.</li> <li>Example:<ul> <li><code>result_page_model.dart</code> parses paginated API responses for various modules.</li> </ul> </li> </ul> <pre><code>@JsonSerializable(createToJson: false)\nclass ResultPageModel extends ResultPage {\n  ResultPageModel(\n    super.current,\n    super.pageSize,\n    super.totalPages,\n    super.totalElements,\n    super.first,\n    super.last,\n  );\n\n  factory ResultPageModel.fromJson(Map&lt;String, dynamic&gt; json) =&gt;\n      _$ResultPageModelFromJson(json);\n}\n</code></pre>"},{"location":"modules/shared/#3-domain-layer","title":"3. Domain Layer","text":"<ul> <li>Contains generic domain abstractions used across modules, such as:</li> <li> <p>Sorting, pagination, filtering, and query result types.</p> <p>Example from cqrs.dart: <pre><code>class Sort {\n    final String field;\n    final String direction;\n\n    Sort(this.field, this.direction);\n}\n\nclass Pagination {\n    final int page;\n    final int pageSize;\n\n    Pagination(this.page, this.pageSize);\n}\n// Other classes like ResultPage, Query, FilteredQuery, etc.    \n</code></pre> These classes facilitate consistent API query building and response handling throughout the app.</p> </li> </ul>"},{"location":"modules/shared/#4-features-layer","title":"4. Features Layer","text":"<ul> <li>Contains shared UI pages and components used across the app:</li> <li>Error pages (404, 401)</li> <li>Home page</li> <li>Landing page</li> <li>Settings page</li> <li>Splash page</li> </ul>"},{"location":"modules/shared/#5-utils","title":"5. Utils","text":"<ul> <li>Utility functions and helpers used app-wide.<ul> <li>Example: GlobalUtils manages web-specific theme mode persistence:</li> </ul> </li> </ul> <pre><code>class GlobalUtils {\n  static void setThemeModeForWeb(String mode) {\n    if (kIsWeb) {\n      final storage = html.window.localStorage;\n      if (mode == 'Light') {\n        storage.update('theme', (value) =&gt; 'light', ifAbsent: () =&gt; 'light');\n      } else if (mode == 'Dark') {\n        storage.update('theme', (value) =&gt; 'dark', ifAbsent: () =&gt; 'dark');\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"modules/shared/#6-widgets","title":"6. Widgets","text":"<ul> <li>Contains shared reusable widgets utilized in various modules.</li> </ul>"},{"location":"modules/shared/#module-registration","title":"Module Registration","text":"<p>The shared module is registered and initialized via:</p> <ul> <li>shared_module.dart \u2014 Handles DI registrations for shared services and BLoCs: <pre><code>Future&lt;void&gt; registerSharedModule() async {\n  // Register BLoCs\n  di.registerSingleton&lt;ThemeModeCubit&gt;(ThemeModeCubit(hive: di())..loadTheme(di()));\n  di.registerSingleton&lt;NavigationService&gt;(NavigationService());\n\n  // Register shared routes\n  di&lt;List&lt;RouteBase&gt;&gt;(instanceName: Constants.mainRouesDiKey).addAll(sharedRoutes());\n}\n\nvoid registerSharedModuleWithContext(BuildContext context) {\n  var navTabs = di&lt;List&lt;AdaptiveDestination&gt;&gt;(instanceName: Constants.navTabsDiKey);\n  navTabs.addAll(getSharedNavTabs(context));\n}\n</code></pre></li> <li> <p>shared_routes.dart \u2014 Defines routes and navigation tabs used by shared features such as home, settings, splash, error pages, and landing.</p> <ul> <li> <p>Example navigation tabs: <pre><code>List&lt;AdaptiveDestination&gt; getSharedNavTabs(BuildContext context) {\n  return &lt;AdaptiveDestination&gt;[\n    AdaptiveDestination(\n      title: context.tr('layoutPage.home'),\n      icon: Icons.home,\n      route: '/home',\n      navTab: SharedNavTab.home,\n      order: 1,\n    ),\n    AdaptiveDestination(\n      title: context.tr('layoutPage.settings'),\n      icon: Icons.settings,\n      route: '/settings',\n      navTab: SharedNavTab.settings,\n      order: 40,\n    ),\n  ];\n}\n</code></pre></p> </li> <li> <p>Example routes: <pre><code>List&lt;GoRoute&gt; sharedRoutes() {\n    return [\n        GoRoute(path: \"/\", redirect: (_, __) =&gt; \"/splash\"),\n        GoRoute(\n        path: '/splash',\n        redirect: initialRedirect,\n        pageBuilder: (context, state) =&gt; FadeTransitionPage(child: const SplashPage()),\n        ),\n        // More routes like error 401, landing, home, settings...\n    ];\n}\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"modules/shared/#summary","title":"Summary","text":"<p>The shared module centralizes:</p> <ul> <li>Reusable blocs and state management</li> <li>Cross-cutting domain models and query abstractions</li> <li>Common utility functions</li> <li>Shared UI components and pages</li> <li>Routing and navigation tabs used across the app</li> </ul> <p>This modular approach encourages clean separation and reuse, reducing code duplication and easing maintenance.</p>"}]}